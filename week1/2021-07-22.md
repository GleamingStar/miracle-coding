# NodeJS

최근 **NodeJS** 가 너무 재밌어서 NodeJS 로 사이드 프로젝트를 진행하고 있다. NPM 이란 생태계도 재밌고, 이런 **라이브러리를 쉽게 기여하고 만들 수 있는 맛**에 쓰는 것 같다.
그렇다면 이 **NodeeJS 는 무엇이며, 어떻게 동작하길래 회사들에서 사용하는 것**일까?

## NodeJS 소개

공식문서에 적혀져 있는 NodeJS 의 소개글을 읽어보자. 주요설명으로 얘기하는 건 **비동기 이벤트 주도의 JavaScript 런타임**이라고 한다.
그렇다면, **비동기 이벤트 주도**는 무엇일까? 일단 우리는 **동기 비동기**에 관해 간단하게 알 필요가 있다.

**NodeJS 소개글 : https://nodejs.org/ko/about/**

**동기 / 비동기**는 무엇일까 우리는 무언가 **동기화를 맞춰가면서 해나갸야 하는 작업을 동기적인 작업**이라고 부른다.

뭐든 어렵게 설명하는것보다 쉽게 설명하는게 좋은 글이므로, 실생활의 예시를 하나들어보겠다.

## 은행 어플리케이션 작업 예시

만약 우리가 은행 어플리케이션의 입금 부분을 만든다고 해보자.
만들게 된다면 로직은 이렇게 될 것이다.

1. 입금할 돈을 입력한다.

2. 입금할 상대방을 입력한다.

3. 내 돈을 먼져 차감 한다.

4. 만약 돈이 부족하다면 입금 프로세스는 취소된다.

5. 만약 돈이 부족하지 않다면 내 잔고가 정상적으로 차감되고 상대에게 돈이 입금된다.

6. 상대방에게 돈이 입금되었는지 확인한다.

7. 정상적으로 입금되었다면 정상입금 카카오톡 메세지를 보내준다.

8. 정상적인 입금이므로 알림페이지를 보내준다.

우리는 위의 프로세스에서 **동기적 작업과 비동기적 작업**을 분리해볼 것 이다.

동기적 작업은 쉽게 Sync 를 맞추면서 해야하는 작업인데, 우리가 만약 3~5 번 프로세스를 만든다고 해보자 4 번 프로세스가 진행되기 위해서는
3번 프로세스에서 반드시 **내 통장의 잔고를 확인**하고, **차감할수 있는지를 확인**하고 **입금**을 해야할 것이다.

즉 우리는 보내는 사람의 통장잔고에 대한 동기화를 계속해서 해줘야 한다. **만약 동기화를 하지 않고도 할 수 있는 작업이라고 해보고 위의 로직을 바꿔보자**

1. 내 통장의 잔고를 확인

2. 최신의 잔고를 확인했는지 안했는지는 모르겠지만 현재 잔고에서 차감할수 있는지도 확인

3. 최신의 잔고가 확인됬는지 안됬는지는 모르겠지만 입금한다. 

아마도 위와 같이 동작할것이다. 즉 비동기는 **1번 2번 3번을 모두 하나의 사건(Event)** 로 보고, **이벤트 처리큐**에 넣어서 **각기 다른 연결성이 없는 이벤트니까 우리는 Sync** 를 안맞추고도 처리해도 되! 라고 하는것이다. 말이 어려울 수도 있다. 근데 쉽게 생각해보자. 위의 로직대로 은행어플리케이션을 만들면 당신의 은행은 망할 수 밖에없을 것이다. 

왜냐 **잔고를 확인하는 이벤트를 처리하는 도중에도 잔고를 차감하는 이벤트가 동시적으로 처리**될 수 있기 때문이다. (**병렬이랑 동시를 헷갈리지 말자!**)

그렇다면 **우리는 언제 비동기적인 사고를 가지고 작업을 처리**해야 할까? 은행 어플리케이션의 7번 부분을 보자

7. 정상적으로 입금이 완료되었다면 => **카카오톡 메세지를 발송**한다.

우리가 입금이 완료되기 전까지는 Sync 를 맞춰줘야하는 작업이 대부분일 것이다. 하지만 그 이후 카카오톡 메세지를 보내주는 부분은 그다지 동기화를 하지 않아도 된다.
왜냐 이미 일련의 **동기화를 맞춰줘야 하는 입금 작업은 완료**되었고, 우리는 **알림 메세지 전송**이라는 **또 다른 이벤트**를 처리하는 것이기 때문이다.

그래서 우리는 이걸 처리하기 위해서 **이벤트 처리 큐로 해당 이벤트를 보낼 것**이다. 
그럼 이벤트 큐에 있는 작업을 어떤 **노동자 스레드**가 처리할 것이다. 보통은 이 노동자 스레드를 **Worker Thread** 라고 한다.

만약 카카오톡 **알림을 보내다가 오류가 나서 종료**되도, 결국 우리의 **입금이 된 사실은 변하지 않는다.** 왜냐면 **다른 이벤트**이기 때문이다.

이미 **입금 이벤트는 종료된 후다. 이점이 상당히 중요한 것**이다. 즉, **동기적 이벤트는 무언가 하나가 잘못되면 Roll back 되야 할 작업일 확률히 상당히 높다.**
왜냐하면 **전체 프로세스가 동기화를 진행하며 이루어지기에**, 뭐 **하나라도 잘못된다면 이전에 동기화를 맞추었던 작업 조차도 되서는 않아야 할 작업이 될 수도 있기 때문**이다.

그러면 반대로 **비동기적 작업은 다른 사건(Event)**이다. 즉 웃기게 얘를 들자면 **A 장소에서 살인사건이 일어나고, B 장소에서 도난 사건이 일어났는데 우리는 이 사건의 공통점**은 딱히 없기에
무언가 사건간의 **교류(동기화)를 할 필요가 없는 것이다. 좋은 예시인 줄은 모르겠으나, 여튼 사건 중심으로 생각하면 다른 이벤트**이다.

그렇다면 이제 **다시 NodeJS 로 돌아가보자!** 아까 NodeJS 는 **비동기 이벤트 주도** 라고 공식문서에 적혀있다고 했다. 이제야 왜 저런 말을 썼는지 이해가 잘 갈것이라고 생각한다.

그럼 NodeJS 는 아키텍쳐를 어떻게 구성하고 있기에 이러한 동작이 가능할 것일까?

## NodeJS Architecture

- 최대한 공식문서에 의거하여 설명하도록 하겠습니다.

### V8

일단 NodeJS 는 **Google 의 V8 엔진**을 채택하였습니다. V8 엔진은 C++ 로 만들어졌으며 **고성능의 WebAssembly & JavaScript 엔진**입니다.
V8 엔진이 더 궁금한 사람은 아래 공식 도큐 먼트를 읽어보면 좋을것 같다.

- V8 : https://v8.dev/docs

### libuv

libuv 는 C 라이브러리로 논 **블로킹 I/O 작업을 지원하는 모든 플랫폼에서 일관된 인터페이스로 추상화** 하는데 사용합니다. NodeJS 에서 사용하는 큰 이유는 
운영체제에서 비동기로 처리될 수 있는 **작업을 처리하기 위한 스레드풀을 포함**하고 있기 때문이다.

- 간단히 싱글스레드라 말하지만, 이런 스레드를 이용하기도 한다. 여튼, **블로킹작업이 있을 수 밖에 없기에 libuv 는 NodeJS 의 핵심**이라고 볼 수 있다.

### NodeJS 구조는?

여러가지 구조 사진을 많이봤지만, 정확한 사진은 아래사진이 아닐까 싶다. 

![](https://rlogimgcontainer.s3.ap-northeast-2.amazonaws.com/정석구조.png)

즉 아까 위에서 **동기 / 비동기에서 설명한 방식으로 모든 이벤트들은 이벤트 루프**에 들어가게 된다.

**노드 JS 의 이벤트 루프 구조는 아래와 같다. (공식 Document 사진이다.)**

![](https://rlogimgcontainer.s3.ap-northeast-2.amazonaws.com/이벤트루프.png)

즉 NodeJS 는 이런식으로 **특정 이벤트가 발생하면, 이벤트 루프에 들어오고, 처리하고 작업이 완료되면 콜백을 발생**시킨다. 
**Blocking 이 있는 작업이 있을 경우 libuv 내부의 libio 를 이용하여 처리**한다.

즉 쉽게 말해 면접 단골문제인 

```
setTimeout(callback, 1000);
```

이 무조건 **1초뒤에 실행되는가를 물어보면 장담할 수 없다고 얘기하는 것이 정답**인 이유가, 각기 다른 이벤트로 분리되기에 우리가 NodeJS 에게 위와 같은 코드로 말하는 것은
setTimeout 이벤트가 처리되고 1초후에 가까운 제일 빠른 시간에 내가 예정한 콜백을 실행시켜 줬으면 좋겠어! 라는 것이다.

즉 쉽게 얘기하면 스케쥴 예약을 하는거지 강제로 시간대를 잡을 수 있는게 아니란 말이다.

일단 이개념을 이해하기 위해서는 아래의 사진을 한번 보자 **노드 JS 의 이벤트 루프 각 섹션**에 대한 설명이다.

![](https://rlogimgcontainer.s3.ap-northeast-2.amazonaws.com/섹션.png)

그럼 위의 사진을 보았으니 공식문서의 코드를 보며 국룰 직문인 setTimeout 에 대해 알아보자!

```javascript
const fs = require('fs');

function someAsyncOperation(callback) {
  // 이 작업이 완료되는데 95ms가 걸린다고 가정합니다.
  fs.readFile('/path/to/file', callback);
}

const timeoutScheduled = Date.now();

const timerCallback = () => {
  const delay = Date.now() - timeoutScheduled;

  console.log(`${delay}ms have passed since I was scheduled`);
};

const someAsyncCallback = () => {
  const startCallback = Date.now();

  // 10ms가 걸릴 어떤 작업을 합니다.
  while (Date.now() - startCallback < 10) {
    // 아무것도 하지 않습니다.
  }
}

setTimeout(timerCallback, 100); // TimeOut Event!!!!😃

// 완료하는데 95ms가 걸리는 someAsyncOperation를 실행합니다.

someAsyncOperation(someAsyncCallback);

```

만약 여러분의 생각대로 Timeout Event 발생후 100ms 안에 작업이 callback 이 작동해야 한다면, console.log 에 얼마나 걸렸는지에 100ms 로 메세지가 나올 것이다.
그러면 우리가 작성한 코드가 NodeJS 의 이벤트 루프상에서 어떻게 존재하는 지 알아보자, 노드는 우리의 코드를 읽을 것이고 `setTimeout(timerCallback, 100);` 이라는 함수를 먼져 맞이한다.
그렇게 되면 100 초 뒤에 **timerCallback 을 작동하므로 timer Phase 에 넣을 것**이다.

그 이후 **someAsyncOperation 이 poll 큐에 들어오고 비동기적으로 작동**할것이고, 95ms 후에 fs.readFile 이 끝나면 poll Phase 에 someAsyncCallback 이 추가 될 것이다. 그래서 10ms 가 더 걸리고 check Phase로 넘어가서 작업이 완료를 될 것이다.
여기서 fs.readFile 같은 경우 Blocking 작업인데, 위에서 설명했듯 libuv 안의 스레드 풀을 이용해서 처리 한다. (이러면 멀티 스레드가 아니냐? 라고 하는데 기저 단계의 커널 스레드 풀을 빌리기에
NodeJS 자체는 싱글스레드 라고 생각한다.)

그리고 **완료되었으니 다시 순회하며 Timers Phase 의 timerCallback 을 실행하게 된다. 그래서 제일 빠른 실행시간이 105ms 가 될수 있는 것**이다.
하지만 이마저도 운영체제의 스레드에 의존하는 작업이 있기에, 스레드 스케쥴링에 의해 더 걸릴 수도 있게 되는 것이다.

여하튼 이해가 안간다면 공식문서를 보는 걸 추천한다. 아니 이해가 가더라도 공식문서를 보자!

NodeJS 이벤트 루프 : https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/

설명이 난잡했는데 해당 개념을 잘 모르는 사람이 꽤 있어서 길어졌다. 여하튼 Node 로 자신의 코드를 실행시킨다면 알아야 하지 않나 싶다...
