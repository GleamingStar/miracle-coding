반쪽덧셈 구현, 전체덧셈 구현, 8비트 덧셈 구현, 10진수 -> 2진수 변환 구현, 2진수 -> 10진수 변환 구현, 10진수 -> 2진수 변환해서 2진수끼리 덧셈한 결과를 10진수로 변환해서 출력	이진 덧셈기는 가능, 진법 변환기의 경우 2^7부터 진행하던 범위를 확장시켜줘야	const length = byteA.length > byteB.length ? byteA.length : byteB.length 식으로 길이값을 설정한 후 그대로 진행한다.	큰 비트를 좌측으로 배치하면 우리가 2진수를 읽는 방식 그대로 나와 이해하기 용이하다. 큰 비트를 우측으로 배치하면 index 0부터 처리하기 용이하다.	"먼저 10<->16진법 함수를 구현한 뒤 두 함수를 거쳐야 할 것 같다.
16>10은 배열을 순환하며 1, 16, 16^2... 를 곱하고
10->16은 16^n을 차례대로 빼는 형태로 구현할 것 같"	위 답변과 동일하다.
day2
가상 환경에 리눅스 설치, ssh 접속 - 로그인 가능 여부, /backup 디렉토리 생성 여부, 백업 자동화 스크립트 - 압축 파일 생성, 백업 자동화 스크립트 - 가상 환경으로 복사	"유닉스 - 벨연구소의 켄톰슨&데니스리치 - 유전적 유닉스, 상표 유닉스, 기능적 유닉스로 나뉘어짐. 리눅스와 미닉스 모두 기능적 유닉스
리눅스 - 리누스 토르발즈 - 미닉스쓰다가 수정안된다고해서 빡쳐서 나옴
미닉스 - 앤드루 타넨바움이 교육목적으로 제작한 운영체제
"	"OS - kernel - shell - User
CLI(TUI)와 GUI로 나뉘어짐
Bash, csh, oh-my-zsh, 파워셸(윈도우 터미널)등"	시스템관리? 사례?	"윈도우 - 윈도우터미널과 WSL2
 - 리눅스를 아에 깔아버리자"
day3
영상 데이터 구조 설계, 영상 데이터 생성, 링크드 리스트 탐색 - render, 링크드 리스트 추가 - add, 링크드 리스트 삽입 - insert, 링크드 리스트 삭제 - delete, 영상 정보 리스트를 출력 화면에 시각적으로 표시	극한(lim n->inf) 이랑 비슷하다. n이 충분히 크다면 n^2+n+342183 따위의 식에서 n^2 이외는 복잡도에, 소요시간에 영향을 주지 못한다. 그러므로 가장 높은 차수의 n;;만 표기한다?	"연속배열이 arraylist를 가리킨다면?
arraylist 는 추가 및 삭제에 불리하고, 인덱스를 통한 조회에 유리하다.
반대로 linkedlist는 추가 및 삭제는 빠르나 인덱스를 통한 조회에는 불리하다.
대량의 데이터를 넣고 조회할 때는 arraylist가, 잦은 데이터의 추가 및 삭제가 있다면 linkedlist가 더 좋다고 할 수 있다."	"대상 index까지 head에서부터 출발하므로 최대 n번 이동한다.
추가 과정에서 제목1~제목13번이 들어간 배열을 무조건 거치는 점이 아쉽다. 이를 어떻게 개선할 수 있을지 고민중이다."	"대상 id까지 head에서부터 찾아가므로 최대 n번 이동한다.
double과 circular를 이용해 거꾸로가거나, 한바퀴 도는 방법이 있을지도 모르겠다.
"	"위와 같다.
대상 id까지 head에서부터 찾아가므로 최대 n번 이동한다.
double과 circular를 이용해 거꾸로가거나, 한바퀴 도는 방법이 있을지도 모르겠다"	"단일 linkedlist의 경우 추가,삭제시 배열처럼 전체를 복사할 필요 없이 앞뒤데이터만 수정하면 되는 linkedlist자체의 장점 빼고는 잘 모르겠다.
double linkedlist의 경우 양방향연결이라 최대 n번 탐색해야 찾을 수 있던 경우도 거꾸로 돌아가 반만 돌고 찾을수 있는 장점이 있다고 한다. 난 구현하지 못했다;;
메모리를 더 잡아먹는 단점이 있다고 하나 대부분 이중연결리스트를 이용한다고 한다.
circular의 경우 순회할 때 끝을 체크할 필요가 없으며 head같은 메타데이터가 필요하지 않다고 한다. head가 없으면 list를 어디다 보관하는지 모르겠다.."	"https://m.blog.naver.com/PostView.nhn?blogId=gi_balja&logNo=221245300411&proxyReferer=https:%2F%2Fwww.google.com%2F
js 프레임워크를 아직 공부하지 못해 잘 모르겠다.."	선입선출, head를 뺀다.	double-ended queue, 스택과 큐를 합친 형태 head에서 빼고 tail에서 빼면 될 것 같다?
day4
직선 좌표 입력, 직선 길이 계산, 직선 길이 출력, 삼각형 좌표 입력, 삼각형 넓이 계산, 삼각형 넓이 출력, 사각형 좌표 입력, 사각형 넓이 계산, 사각형 넓이 출력, 입력값 범위와 예외 처리	"클래스 - 객체를 만들어내기 위한 설계도
오브젝트 - 소프트웨어 세계에 구현할 대상
인스턴스 - 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적 실체
https://opentutorials.org/course/1223/5400
https://dongkka.tistory.com/22"	"상속 - 자식클래스가 부모클래스의 속성이나 메서드를 이용할 수 있는 것?
다형성이란 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것을 의미한다.
https://opentutorials.org/course/1223/6127"	"js에선 차이가 너무 명확하다?
super는 부모클래스 this는 자기클래스"	"클래스로 선언 한것을 객체라 하고, 그 객체가 메모리에 할당 되어질때(new) 인스턴스 라고 한다.
객체는 현실세계에 가깝고, 인스턴스는 관계의 초점에 가까운 개념 (객체는 클래스의 인스턴스)
https://dongkka.tistory.com/22"	"single responsibility principle : 객체는 단 하나의 책임만 가져야 한다
응집도는 높게, 결합도는 낮게
여러 객체들이 하나의 책임만 갖도록 잘 분배한다면, 시스템에 변화가 생기더라도 영향이 최소화"	open closed principle : 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계해야 한다	"liskov substitution principle : 자식 클래스는 최소한 자신의 부모클래스에서 가능한 행위는 수행할 수 있어야 한다
자식클래스는 부모클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행"
day5
ClassifierAlpha 함수형 리팩토링, PrimeAlpha 함수형 리팩토링, 순수 함수 구현 (참조투명성 + 불변성), 고차 함수 활용	"이미 생명주기가 끝난 외부함수의 변수(자유변수)를 참조하는 함수
function 달러to원 () {
    const 환율 = 1300
     return function 변환(val) {
        return val*환율
    }
}
const test = 달러to원
console.log(test(대충바꿀돈))
여기서 달러to원 안의 변수 '환율'이 내부함수 '변환'에 의해 참조되고 있어 계속 살아있다."	"바깥값에 영향을 주지 않고 input->output 형태의 함수
동일한 값을 넣으면 항상 동일한 값의 출력을 보장한다"	"n차방정식처럼 함수가 여려겹 겹친? 콜백, 내부함수 등으로
대표적으로 map,reduce 등도 고차함수이다
map(1차) = 배열에 각각에 요소에 대해 이하 내부함수를 실행
내부함수(2차) = 주어진 요소에 실행"	"프로그래밍 하는 방식, 각자 더 나은 코딩을 지향한다.
이를 참고하여, 예를 들어 OOP에서는 객체간의 소통 및 다형성, SOLID원칙 따위를 지키며, FP에서는 유지보수의 용이성, side effect의 제거 따위를 목표로 하는 이러한 방식들을 참고하며 더 나은 프로그래밍을 할 수 있다?
개인적으로 에러를 줄이기 위한 코딩방식도 좋지만, 누구나 알아 볼 수 있게 하는 코딩방식이 제일이라고 생각하는데 FP든 OOP든 하나로 정해서 통일했으면 좋겠다. 그러면 남의 코드를 알아보기 위해 둘 다 공부할 필요까지는 없어질텐데"	"둘 다 유지보수의 용이성이나, 가독성을 고려한 방식이다
OOP는 객체간의 소통을 중요시하고, 거대한 코딩? 큰 규모의 프로젝트에 어울리며
FP는 고차함수, 불변성, 순수함수 등을 중요시하며 분산 프로그래밍에 용이하다
how to solve VS what to solve
???
그리고 FP가 가독성을 생각했을까? 아닌것같은"