# 21.07.07 수요일

## 📘 Webpack

웹팩은 html, css, js 파일을 모두 하나의 파일로 합쳐주는 번들러이다. entry point에서 시작해서, 의존적인 모듈을 전부 찾아내서 하나의 결과물을 만들어낸다. 웹팩을 사용하기 위해서, 번들 작업을 하는 webpack 패키지와 웹팩 터미널 도구인 webpack-cli를 설치한다.

```jsx
$ npm install -D webpack webpack-cli
or
$ yarn add -D webpack webpack-cli
```

### 웹팩 설정하기

설치가 완료되면 `node_modules/.bin` 폴더에 실행 가능한 명령어가 몇 개 생긴다. `—-mode`, `—-entry`, `—-output` 옵션을 사용해서 코드들을 묶을 수 있다.

- `--mode` 웹팩 실행 모드 (개발 모드에서는 develop 지정)
- `--entry` 시작점 경로
- `--output` 번들링 결과물을 위치할 경로

```jsx
$ node_modules/.bin/webpack --mode development --entry ./src/app.js --output dist/main.js
```

매번 위와 같이 명령어를 치고 있을 수는 없다. `--config` 옵션으로 웹팩 설정 파일의 경로를 지정할 수 있는데 기본 파일명은 `webpack.config.js` 혹은 `webpackfile.js` 이다. `webpack.config.js` 파일을 만들어서 명령어로 설정했던 것을 코드로 구성해보자.

```jsx
const path = require('path');

module.exports = {
  mode: 'development',
  entry: {
    main: './src/app.js',
  },
  output: {
    filename: '[name].js',
    path: path.resolve('./dist'),
  },
};
```

- `output`에 설정한 `[name]` 에는 `entry`에 추가한 `main`이 문자열로 들어온다.
- `output.path` 는 절대 경로를 사용하기 때문에, path 모듈의 `resolve()` 함수를 사용해서 계산했다. path는 노드 코어 모듈 중 하나로, 경로를 처리하는 기능을 제공한다.
- Vending Machine 프로젝트 때 설정한 `webpack.config.js` [링크](https://github.com/dyongdi/fe-w7-vm/blob/Qtumn/webpack.config.js)
  - 위 예제와 약간 차이점이 있다.
  - entry point를 배열로 해서 두 개를 뒀고,
  - `path.resolve` 에도 인자를 두 개 넣었다.
  - `filename` 은 `bundle.js` 라고 명시해주었다.

웹팩 실행을 위해 npm 커스텀 명령어를 추가한다. 말도 안되게 길었던 명령어를 커스텀 명령어로 써주는 것이다.

```json
// package.json
{
  "scripts": {
    "build": "./node_modules/.bin/webpack"
  }
}
```

이제는 `npm run build` 로 웹팩 작업을 지시할 수 있게 되었다.

---

### 로더

웹팩은 모든 파일을 모듈로 바라본다. 자바스크립트 모듈 뿐 아니라 스타일시트, 이미지, 폰트까지 전부 모듈로 본다. 따라서 `import` 구문을 사용해서 자바스크립트 코드 안으로 가져올 수 있다.

이것이 가능한 이유가 바로 웹팩의 **로더** 덕분이다.

- 타입스크립트 같은 다른 언어를 자바스크립트 문법으로 변환해줌
- 이미지를 data URL 형식의 문자열로 변환함
- CSS 파일을 자바스크립트에서 직접 로딩할 수 있도록 해줌

VM 프로젝트에서 했던 설정을 보면, scss 파일을 entry point로 추가해줬는데, 그럴 필요 없이 main.js에서 바로 import 해서 사용하면 되는 것이다.

```json
// VM 프로젝트의 webpack.config.js 중 일부
"entry": ['./src/main.js', './src/sass/main.scss'],
```

자주 사용하는 로더는 4가지 정도가 있다.

- css-loader
- style-loader
- file-loader
- url-loader

### css-loader

CSS 파일을 자바스크립트에서 불러와 사용하려면, CSS를 모듈로 변환하는 작업이 필요하다. 이 작업을 css-loader가 해준다. 로더를 설치하고, 웹팩 설정에 로더를 추가한다.

```jsx
$ npm install -D css-loader
or
$ yarn add -D css-loader
```

```json
module.exports = {
	module: {
		rules: [
			{
				test: /\.css$/,
				use: ["css-loader"],
			}
		],
	},
}
```

빌드를 하면 CSS코드가 자바스크립트로 변환된 것을 확인할 수 있다.

### style-loader

모듈로 변경된 스타일 시트는 돔에 추가되어야만 브라우저가 해석할 수 있다. css-loader로 처리하면 자바스크립트 코드로만 변경되었을 뿐, 돔에 적용되지 않았기 때문에 스타일이 적용되지 않는다.

style-loader는 자바스크립트로 변경된 스타일을 동적으로 돔에 추가하는 로더이다. CSS를 번들링하기 위해서는 css-loader와 style-loader를 함께 사용해야 한다. SASS를 사용했다면, sass-loader도 사용해야 한다.

로더를 설치하고, 웹팩 설정에 로더를 추가한다.

```jsx
$ npm install -D style-loader
or
$ yarn add -D style-loader
```

```json
module.exports = {
	module: {
		rules: [
			{
				test: /\.css$/,
				use: ["style-loader", "css-loader"],
			}
		],
	},
}
```

배열로 설정하면 뒤에서부터 앞의 순서로 로더가 동작하기 때문에 style-loader를 앞에 써준다.

---

### 플러그인

로더가 파일 단위로 처리하는 반면, 플러그인은 번들된 결과물을 처리한다. 번들된 자바스크립트를 난독화하거나 특정 텍스트를 추출하는 용도로 사용한다. 플러그인도 마찬가지로 커스텀할 수 있다. 자주 사용하는 플러그인은 다음과 같다.

- BannerPlugin : 빌드된 결과 모드에 배너(주석)를 달 수 있음. 빌드 시간이나 커밋 정보 등을 써놓는다.
- DefinePlugin : 개발환경과 운영환경이 다른데, 대표적인 예로 API 서버 주소가 다를 수 있다. 이러한 환경 의존적인 정보를 소스코드가 아닌 곳에서 관리하는 것이 좋다. DefinePlugin은 이런 환경 정보를 제공한다. 또한 빌드 타임에 결정된 값을 어플리케이션에 전달할 때 사용하기도 한다.
- HtmlWebpackPlugin : HTML 파일을 후처리하는 데 사용한다. 빌드 타임의 값을 넣거나 코드를 압축할 수 있다. (패키지 다운로드 필요) 환경 변수에 따라 (개발용) 문자열을 붙인다던지, 운영 환경에서 공백을 모두 제거하고 불필요한 주석을 제거한다던지, 이런 기능을 가지고 있다.
- CleanWebpackPlugin : 빌드 이전 결과물을 제거하는 플러그인. (패키지 다운로드 필요)
- MiniCssExtractPlugin : 스타일시트가 점점 많아지면 하나의 자바스크립트 결과물로 만드는 것이 부담일 수 있다. 번들 결과에서 스타일시트 코드만 뽑아서 별도의 CSS 파일로 만들어 역할에 따라 파일을 분리하는 것이 좋다. 큰 파일 하나를 내려받는 것보다 여러 개의 작은 파일을 동시에 다운로드하는 것이 더 빠르기 때문. (패키지 다운로드 필요)

<br>

## 📘 PORT, DNS

### PORT

한번에 둘 이상 연결해야 하는 경우 (예 - PC로 게임도 하고, 화상통화도 하고, 웹 브라우저 요청도 하고 있을 때) 클라이언트 PC가 여러 개의 서버랑 통신해야 한다. 내 IP로 패킷들이 날아오는데, 게임에서 필요한 패킷인지 화상통화에서 필요한 패킷인지 웹 브라우저의 응답 결과로 온 패킷인지 알 수가 없다. 보낼 때도 마찬가지.

이걸 구분하기 위해 TCP, UDP에 출발지 PORT, 목적지 PORT 정보가 담겨 있다.

같은 IP 내에서 프로세스를 구분하는 게 PORT의 역할

- 0 ~ 65535 할당 가능
- 0 ~ 1023 : 잘 알려진 포트. 사용하지 않는 것이 좋음
  - FTP - 20, 21
  - TELNET - 23
  - HTTP - 80
  - HTTPS - 443

### DNS (Domain Name System)

IP는 기억하기 어렵고, 변경될 수 있다.

DNS 서버에 도메인을 등록해서 전화번호부처럼 쓸 수 있다.

<br>

## 📘 모자스 6장

## 6장. 데이터 타입

- undefined 타입은 'var 키워드로 선언된 변수에 암묵적으로 할당되는 값' 이었다.
- 자바스크립트의 숫자 타입은 정수만을 위한 타입이 없고 모든 수를 실수로 처리한다. 따라서 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있다. 다른 언어에서는 안 그러는구나..

  ```jsx
  console.log(1 === 1.0); // true
  ```

### 템플릿 리터럴

- 백틱을 사용한 문자열 표기법
- 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공
  - 표현식 삽입은 `${}` 이거! 표현식의 평가 결과가 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 삽입된다.
- 런타임에 일반 문자열로 변환되어 처리

### undefined

- 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화한다. (사실 대부분 비어 있지 않고 garbage value가 들어 있다. 아무튼 초기화한다.)
- undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라, 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다.
- 따라서 undefined를 개발자가 의도적으로 변수에 할당한다면 undefined의 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 권장하지 않는다. 대신 null을 사용하자.

### 선언(declaration) vs 정의(definition)

- ECMAScript 사양에서 변수는 '선언'한다, 함수는 '정의'한다 라고 표현하고 있다.
- 자바스크립트의 경우 변수를 선언하면 암묵적으로 정의가 이뤄지기 때문에 선언과 정의의 구분이 모호하다.
- 다른 언어에서는 선언과 정의를 엄격하게 구분해서 사용한다.
  - 선언 : 컴파일러에게 식별자의 존재만 알리는 것
  - 정의 : 실제로 컴파일러가 변수를 생성해서 식별자와 메모리 주소가 연결된 상태

### Symbol 타입

- ES6에서 추가된 7번째 원시 타입
- 변경 불가능하고, 다른 값과 중복되지 않는 유일무이한 값
- 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용
- 리터럴을 통한 생성이 불가능함. Symbol 함수 호출해서 생성해야 함
- 생성된 심벌 값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않음

## 🥕 회고

- 왠지 집중이 잘 안 됐던 하루! 팀 미션 할 때는 졸리다고 자고 오거나 이런 게 없었는데 역시 혼자 공부하다보니까 졸리면 자고.. 집중 안 되면 딴짓하고.. 흐음
- Webpack에 대해 공부했는데 아직 알쏭달쏭하다. 하나로 다 합쳤다가 너무 크면 코드 스플리팅을 한다고 해서, 아니? 다시 나눌거면 뭐하러 합치는 거야? 라고 생각했다. 홍태의한테 물어봤는데 웹팩이 의존성 관리도 해주고 바벨같은 것도 해주고 뭐 그렇다고 한다. 단순히 코드를 합치는 것 외에 부가적인 기능이 있는 듯.. 웹팩 등장 이전에는 어땠고 웹팩의 역할이 뭔지 더 공부해봐야겠다.
- 이슈트래커 플젝 하면서 맨날 늦게 잤더니 그게 습관이 돼서 계속 늦게 자고 10시에 일어나자마자 책상 앞에 앉고 이러고 있다. 원래는 아주 일찍 일어나진 않았어도 9시 20분에는 일어나서 씻고 책상 앞에 앉았었는데.. 조금 일찍 자고 일찍 일어나보자.
